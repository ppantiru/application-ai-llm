<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.5" reference="AI.Code.Javascript" locale="">
  <web>AI.Code</web>
  <name>Javascript</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>AI.Code.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <originalMetadataAuthor>XWiki.MunozMateo</originalMetadataAuthor>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity}}
#set($MyDoc = $xwiki.getDocument("AI.Code.AIConfig"))
#set($class = $xwiki.getClass("AI.Code.AIConfigClass"))
#set($objArray = [])

#foreach($obj in $MyDoc.getObjects("AI.Code.AIConfigClass"))
  #set($objData = [])  ## Créez un nouveau tableau pour chaque objet
  #set($discard = $MyDoc.use($obj))
  #foreach($prop in $class.properties) ## Parcourez toutes les propriétés
    ## Ajoutez chaque propriété au tableau de l'objet
    #set($value = $MyDoc.display($prop.getName()))
    #set($discard = $objData.add({ "property": $prop.name, "value": $value }))
  #end

  ## Ajoutez le tableau de l'objet au tableau principal
  #set($discard = $objArray.add($objData))
#end
{{/velocity}}</content>
  <object>
    <name>AI.Code.Javascript</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>62bb6859-7384-4746-a4b3-7c2cb018653e</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <restricted>0</restricted>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>define("xwiki-llm", ['jquery', 'xwiki-events-bridge'], function ($) {
  var initDone = false;
  var nbAssistMsg = 0;
  var context = new Array();
  let contextSize = 0;
  let nbToken = 0;
  let btnEnabled = true;
  let maxToken = 2000;


  define('llm-translation', {
    prefix: 'llm.',
    keys: [
      "ui.copy",
      "ui.include",
      "ui.copyLabel",
      "ui.includeLabel",
      "ui.assistantInfoName",
    ]
  });
  let copyBtnValue;
  let copyBtnLabel
  let includeBtnValue;
  let includeBtnLabel;
  let assistInfoName;
  require(['xwiki-l10n!llm-translation'], function (l10n) {
    copyBtnValue = l10n.get('ui.copy');
    includeBtnValue = l10n.get('ui.include');
    copyBtnLabel = l10n.get('ui.copyLabel');
    includeBtnLabel = l10n.get('ui.includeLabel');
    assistInfoName = l10n.get('ui.assistantInfoName');
  });


  // controler to stop a request if needed.
  let globalAbortController = new AbortController();
  let globalSignal = globalAbortController.signal;

  var loadCSS = function (url) {
    $('&lt;link&gt;').attr({
      type: 'text/css',
      rel: 'stylesheet',
      href: url
    }).appendTo('head');
  };

  var css = [
    // Styles for the editor UI (tool bar, dialogs, etc.).
    new XWiki.Document(XWiki.Model.resolve("AI.Code.StyleSheet", XWiki.EntityType.DOCUMENT)).getURL('ssx'),
  ];
  css.forEach(loadCSS);

  // Scroll to the bottom of the chat content
  function scrollToBottom() {
    const chatContent = document.querySelector('#chatContent');
    chatContent.scrollTop = chatContent.scrollHeight;
  }

  function isJSON(str) {
    try {
      JSON.parse(str);
    } catch (e) {
      return false;
    }
    return true;
  }

  function addUserChat(userChat) {
    const preElement = document.createElement('pre');
    preElement.classList.add('user-message');

    const msgInfo = document.createElement('div');
    msgInfo.classList.add('msg-info');
    msgInfo.textContent = 'User';
    preElement.appendChild(msgInfo);

    const userMessage = document.createElement('div');
    userMessage.id = `user-content-${nbAssistMsg}`;
    userMessage.textContent = userChat;
    preElement.appendChild(userMessage);

    const userMsgButtons = document.createElement('div');
    userMsgButtons.classList.add('msgButtonWrapper');

    const msgBtn = document.createElement('button');
    msgBtn.classList.add('userMsgButton');
    msgBtn.type = 'button';
    msgBtn.id = `user-btn-${nbAssistMsg}`;
    msgBtn.title = 'Move the message in the message edition area.';
    msgBtn.textContent = 'Edit';
    userMsgButtons.appendChild(msgBtn);
    preElement.appendChild(userMsgButtons);

    return preElement;
  }


  function addAssistantChat(assistantChat, model, elapsedTime) {
    nbAssistMsg++;
    const div = document.createElement('div');
    div.id = `assist-msg-${nbAssistMsg}`;
    div.classList.add('assistant-message');

    const modelInfo = document.createElement('div');
    modelInfo.classList.add('msg-info');
    modelInfo.id = `mod-inf-${nbAssistMsg}`;
    modelInfo.textContent = `${assistInfoName} (${model}) - ${elapsedTime} sec`;
    div.appendChild(modelInfo);

    const messageContent = document.createElement('pre');
    messageContent.classList.add('message-content');
    messageContent.id = `msg-content-${nbAssistMsg}`;
    messageContent.textContent = assistantChat;
    div.appendChild(messageContent);

    const astMsgButton = document.createElement('div');
    astMsgButton.classList.add('astMsgButtonWrapper');

    const copyButton = document.createElement('button');
    copyButton.type = 'button';
    copyButton.classList.add('copy-button');
    copyButton.id = `copy-button-${nbAssistMsg}`;
    copyButton.style.display = 'none';
    copyButton.title = copyBtnLabel;
    copyButton.textContent = copyBtnValue;
    astMsgButton.appendChild(copyButton);

    const includeButton = document.createElement('button');
    includeButton.type = 'button';
    includeButton.classList.add('include-button');
    includeButton.id = `include-button-${nbAssistMsg}`;
    includeButton.style.display = 'none';
    includeButton.title = includeBtnLabel;
    includeButton.textContent = includeBtnValue;
    astMsgButton.appendChild(includeButton);

    div.appendChild(astMsgButton);

    return div;
  }


  function addSystemChat(msg) {
    const divElement = document.createElement('div');
    divElement.id = 'system-msg';
    divElement.classList.add('system-message');

    const systemInfo = document.createElement('div');
    systemInfo.classList.add('msg-info');
    systemInfo.textContent = 'System';
    divElement.appendChild(systemInfo);

    const messageContent = document.createElement('pre');
    messageContent.classList.add('message-content');
    messageContent.textContent = msg;
    divElement.appendChild(messageContent);

    return divElement;
  }


  // Add the loading animation to the interface.
  function addLoading(chatContent) {
    chatContent.innerHTML += `&lt;div class="waiting-line"&gt;
&lt;div class="dot dot1"&gt;&lt;/div&gt;
&lt;div class="dot dot2"&gt;&lt;/div&gt;
&lt;div class="dot dot3"&gt;&lt;/div&gt;
&lt;/div&gt;
`;
    scrollToBottom();
  }

  // Remove the loading animation from the interface.
  function removeLoading(chatContent) {
    const loadingLine = chatContent.querySelector('.waiting-line');
    if (loadingLine) {
      loadingLine.remove();
    }
  }


  function updateAssistantChat(msgIdNum, updatedTime, chunkReply, model) {
    document.querySelector('#mod-inf-' + msgIdNum).textContent = `${assistInfoName} (${model}) - ${updatedTime} sec`;
    document.querySelector('#msg-content-' + msgIdNum).textContent += chunkReply;
  }

  function errorMessagePrint(errorMessage) {
    return `&lt;div class="errorHandler"&gt;${errorMessage}&lt;/div&gt;`;
  }

  function copyTextToClipboard(numMsgToCopy) {
    return new Promise((resolve, reject) =&gt; {
      const numericID = numMsgToCopy.replace("copy-button-", "");
      const numMsg = parseInt(numericID);
      const text = document.querySelector('#msg-content-' + numMsg).textContent;
      window.getSelection().selectAllChildren(document.querySelector('#msg-content-' + numMsg));
      document.execCommand("Copy");
      window.getSelection().removeAllRanges();
      resolve(text);
    });
  }

  function includeInDoc(msgID) {
    return new Promise((resolve, reject) =&gt; {
      const numericID = msgID.replace("include-button-", "");
      const numMsg = parseInt(numericID);
      const text = document.querySelector('#msg-content-' + numMsg).textContent;
      resolve(text);
    });
  }
  
  function editUserMsg(msgID){
    return new Promise((resolve, reject) =&gt;{
      const numericID = msgID.replace("user-btn-", "");
      const numMsg = parseInt(numericID);
      const text = document.querySelector('#user-content-' + numMsg).textContent;
      document.querySelector('#txt-input').value = text;
      resolve(text);
    })
  }

  function chooseMaxToken(modelType) {
    if (modelType !== 'openai') {
      return 2000;
    }
    else return 4000;
  }

  function countTokens(query) {
    query = query.trim();
    const words = query.split(' ');
    const filteredWords = words.filter(word =&gt; word !== '');

    // One token equal to approximatively 1.3 token (based on OpenAI tokenization)
    const tokenCount = filteredWords.length * 1.3;

    return Math.floor(tokenCount);
  }

  function getRequestParams(userText, modelType, model, prompt, context) {
    const params = {
      text: userText,
      modelType: modelType,
      model: model,
      prompt: context + prompt,
    };
    return params;
  }

  function getRequestOptions(params, csrf) {
    const options = {
      method: 'POST',
      body: JSON.stringify(params),
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrf
      },
      signal: globalSignal
    };
    return options;
  }

  function tokenManager() {
    nbToken += countTokens(context[contextSize]);
    contextSize++;
    // Manage the number of token so the request is not too long.
    let ind = 0;
    while (nbToken &gt; maxToken) {
      nbToken -= countTokens(context[ind]);
      context.shift();
      ind++;
    }
  }

  function handleButtonClick(event) {
    return new Promise(function (resolve) {
      const target = event.target;
      const msgID = target.id;
      if (target.classList.contains('copy-button')) {
        copyTextToClipboard(msgID);
      }
      else if(target.classList.contains('userMsgButton')){
        editUserMsg(msgID);
      }
      resolve(msgID);
    });
  }

  // Update the interface and the context with the new infos (non-streaming request only here).
  function updateChat(chatContent, generatedContent, model, elapsedTime, userText) {
    removeLoading(chatContent);
    chatContent.appendChild(addAssistantChat(generatedContent, model, elapsedTime));
    let actualMsgID = nbAssistMsg;
    document.querySelector('#copy-button-' + actualMsgID).style.display = "block";
    document.querySelector('#include-button-' + actualMsgID).style.display = "block";
    context[contextSize] = 'user: ' + userText + '\n';
    context[contextSize] += 'assistant: ' + generatedContent + '\n';
    tokenManager();
  }

  function initChatOnStream(chatContent, model) {
    removeLoading(chatContent);
    chatContent.appendChild(addAssistantChat('', model, 0));
    scrollToBottom();
  }

  function updateChatOnStream(chatContent, completedReply) {
    context[contextSize] += completedReply;
    tokenManager();
    scrollToBottom();
  }

  function errorCatcher(chatContent, error) {
    chatContent.innerHTML += errorMessagePrint("An error occured: " + error.message);
  }

  function changeBtnState() {
    if (btnEnabled) {
      document.querySelector('#subButton').disabled = true;
      document.querySelector('#clearWin').disabled = true;
      document.querySelector('#stopRqst').style.display = "block";
      btnEnabled = false;
    }
    else {
      document.querySelector('#subButton').disabled = false;
      document.querySelector('#clearWin').disabled = false;
      document.querySelector('#stopRqst').style.display = "none";
      btnEnabled = true;
    }
  }

  function handleValidChunk(jsonMessages, completedReply, beginRep, isErr, model, startTime, userText) {
    for (const jsonMessage of jsonMessages) {
      if (jsonMessage.trim() !== '') {
        const message = JSON.parse(jsonMessage);
        let reply = '';
        // Extract the generated reply from the response
        if (message.choices[0].finish_reason !== 'stop') {
          reply = message.choices[0].delta.content;
        }

        // Handle the generated reply as desired
        if (reply) {
          completedReply += reply;
          if (completedReply.indexOf("An error occured") !== -1) {
            isErr = true;
            chatContent.innerHTML += errorMessagePrint(reply);
          }
          else if (completedReply.indexOf('ERROR: ') !== -1) {
            isErr = true;
            chatContent.innerHTML += errorMessagePrint("An error occured: " + completedReply);
          }
          else {
            if (beginRep) {
              initChatOnStream(chatContent, model);
              beginRep = false;
            }
            const elapsedTime = (Date.now() - startTime) / 1000;
            updateAssistantChat(nbAssistMsg, elapsedTime, reply, model);
          }
        }

      }
    }
    return { isErr, beginRep, completedReply };
  }

  function processStream({ done, value }, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText) {
    try {
      if (done) {
        if (!isErr) {
          document.querySelector('#copy-button-' + nbAssistMsg).style.display = "block";
          document.querySelector('#include-button-' + nbAssistMsg).style.display = "block";
          context[contextSize] += userText;
          updateChatOnStream(chatContent, completedReply);
        }
        else {
          if (isJSON(accumulatedChunks)) {
            let message = JSON.parse(accumulatedChunks);
            errorCatcher(chatContent, message.error);
          }
        }
        changeBtnState();
        return;
      }
      else {
        accumulatedChunks += value;

        // Extract complete JSON messages
        let jsonMessages;
        let isValidChunk = true;
        if (accumulatedChunks.indexOf('data: ') !== -1) {
          jsonMessages = accumulatedChunks.split('data: ').filter(Boolean);
        }
        else {
          isValidChunk = false;
        }
        // Process complete JSON messages
        if (isValidChunk) {
          accumulatedChunks = jsonMessages.pop(); // Keep the incomplete message for the next iteration
          ({ isErr, beginRep, completedReply } = handleValidChunk(jsonMessages, completedReply, beginRep, isErr, model, startTime, userText));
          return reader.read().then(value =&gt;
                                    processStream(value, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText));
        }
        else
          return reader.read().then(value =&gt;
                                    processStream(value, chatContent, completedReply, accumulatedChunks, true, beginRep, reader, model, startTime, userText));
      }
    } catch (error) {
      console.error('error stream : ', error);
    }

  }

  function streamResponse(chatContent, stream, model, startTime, userText) {
    const reader = stream.getReader();
    let accumulatedChunks = '';
    let completedReply = '';
    let isErr = false;
    let beginRep = true;

    return reader.read().then(value =&gt;
                              processStream(value, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText));
  }

  function streamingRequest(chatContent, URI, options, startTime, model, userText) {
    addLoading(chatContent);
    fetch(URI, options).then((response) =&gt; {
      const reader = response.body.getReader();
      return new ReadableStream({
        start(controller) {
          function push() {
            reader.read().then(({ done, value }) =&gt; {
              if (done) {
                controller.close();
                return;
              }
              const chunk = new TextDecoder().decode(value);
              controller.enqueue(chunk);
              push();
            });
          }
          push();
        }
      });
    }).then((stream) =&gt; {
      return streamResponse(chatContent, stream, model, startTime, userText);
    }).catch((error) =&gt; {
      if (error.name !== 'AbortError') {
        console.error('Error:', error);
        errorCatcher(chatContent, error);
        changeBtnState();
      }
    });
  }

  function requestModeResponse(URI, options, start, model, chatContent, userText) {
    addLoading(chatContent);
    fetch(URI, options)
      .then(response =&gt; response.json())
      .then(data =&gt; {
      const elapsedTime = (Date.now() - start) / 1000;
      if (data.code) {
        console.error(data.code);
        chatContent.innerHTML += errorMessagePrint("An error occured: " + data.code + " " + data.description);
      } else if (data.error) {
        console.error(data.error);
        chatContent.innerHTML += errorMessagePrint("An error occured: " + data.error.message);
      } else {
        const content = data.choices[0].message.content;
        if (content.indexOf('ERROR: ') != -1) {
          chatContent.innerHTML += errorMessagePrint("An error occured: " + content);
        }
        else {
          updateChat(chatContent, content, model, elapsedTime, userText);
        }
      }
      scrollToBottom();
      changeBtnState();
    })
      .catch(error =&gt; {
      // Handle any errors except abort error, because
      // this happen on purpose.
      if (error.name !== 'AbortError') {
        changeBtnState();
        console.error(error);
        errorCatcher(chatContent, error);
      }
    });
  }

  function postRequest(options, chatContent, model, userText, isStreaming) {
    changeBtnState();
    document.querySelector('#txt-input').value = '';
    const URI = "/xwiki/rest/v1/chat/completions";
    const start = Date.now();
    if (isStreaming === "true") {
      streamingRequest(chatContent, URI, options, start, model, userText);
    }
    else requestModeResponse(URI, options, start, model, chatContent, userText);

  }

  function getPrompts(options) {
    const chatContent = document.querySelector('#chatContent');
    changeBtnState();
    document.querySelector('#stopRqst').style.display = "none";
    chatContent.appendChild(addSystemChat('Prompts are loading..'));
    fetch('/xwiki/rest/v1/prompts', options)
      .then(response =&gt; {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
      .then(json =&gt; {
      initPromptMenu(json);
      changeBtnState();
      document.querySelector('#stopRqst').style.display = "none";
      chatContent.appendChild(addSystemChat('Prompts are loaded.'));
    })
      .catch(e =&gt; {
      console.error('An error occured trying to get the prompt list : ' + e.message);
      chatContent.appendChild(addSystemChat('An error occured trying to get the prompt list : ' + e.message +
                                            '.'));
    })
  }

  function getModels(options) {
    const chatContent = document.querySelector('#chatContent');
    changeBtnState();
    document.querySelector('#stopRqst').style.display = "none";
    chatContent.appendChild(addSystemChat('Models are loading..'));
    fetch('/xwiki/rest/v1/models', options)
      .then(response =&gt; {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
      .then(json =&gt; {
      if (Object.keys(json).length === 0) {
        throw new Error('There is no models to load');
      }
      else {
        initModelMenu(json);
        chatContent.appendChild(addSystemChat('Models are now loaded.'));
        changeBtnState();
      }
    })
      .catch(e =&gt; {
      console.error('An error occured trying to get the model list : ' + e.message);
      chatContent.appendChild(addSystemChat('An error occured trying to get the model list : ' + e.message +
                                            '. Please make sure to have at least one configuration working.'));
    });
  }

  function submitChat(event, form) {
    event.preventDefault(); // Prevent the form from submitting normally
    // Get the text from the textarea
    const userText = "" + form.elements.input.value;
    if (userText === "") {
      alert("Your request is empty, please write an input.");
      return false;
    }

    // Which model should we adress and what feature is wanted
    const modelMenu = document.querySelector('#model-menu');
    const selectedMod = modelMenu.value;
    const modelType = selectedMod.substring(0, selectedMod.indexOf("/"));
    const model = selectedMod.substring(selectedMod.indexOf("/") + 1);
    const selectedPrompt = document.querySelector('#features-menu').value;
    const prompt = selectedPrompt;
    const isStreaming = modelMenu.options[modelMenu.selectedIndex].getAttribute("data-streaming");;
    maxToken = chooseMaxToken(modelType);
    // Adding the user chat in the page
    const chatContent = document.querySelector('#chatContent');
    if (prompt !== '') {
      chatContent.appendChild(addSystemChat('The prompt used is: ' + prompt));
    }
    chatContent.appendChild(addUserChat(userText));
    scrollToBottom();

    // Create the string containing csrf token
    const csrf = '${services.csrf.token}';

    const params = getRequestParams(userText, modelType, model, prompt, context, isStreaming);
    const options = getRequestOptions(params, csrf);

    // Make the POST request with query parameters
    postRequest(options, chatContent, model, userText, isStreaming);

  }

  function abortRequest() {
    globalAbortController.abort();
    const chatContent = document.querySelector('#chatContent');
    chatContent.appendChild(addSystemChat("You aborted the ongoing request."));
    removeLoading(chatContent);
    scrollToBottom();
    changeBtnState();
    // reset the signal
    globalAbortController = new AbortController();
    globalSignal = globalAbortController.signal;
  }

  function initFormEvent(form) {
    // Add an event listener to the form submit event
    form.addEventListener('submit', (event) =&gt; { submitChat(event, form) });

    const clearWinButton = document.querySelector('#clearWin');
    clearWinButton.addEventListener('click', (event) =&gt; {
      document.querySelector('#chatContent').innerHTML = '';
      nbAssistMsg = 0;
      context = [];
      nbToken = 0;
    });

    const stopRqstButton = document.querySelector('#stopRqst');
    stopRqstButton.addEventListener('click', (event) =&gt; {
      abortRequest();
    });
  }

  function initModelMenu(modelList) {
    const modelMenu = document.querySelector('#model-menu');
    modelList.forEach(element =&gt; {
      const prefix = element.prefix;
      const filter = element.filter;
      const filterTab = filter.split(',');
      const isStreaming = element.canStream;
      for (let model of element.data) {
        const value = prefix + '/' + model.id;
        const valueToDisplay = model.id + ' (' + prefix + ')';
        if (filterTab.includes(model.id) || filter === '')
          modelMenu.innerHTML += `&lt;option value="${value}" data-streaming="${isStreaming}"&gt;${valueToDisplay}&lt;/option&gt;`
      }
    });

  }

  function initPromptMenu(promptList){
    promptList.forEach(element =&gt;{
      const name = element.name;
      const prompt = element.prompt;
      const isActive = element.active;
      const isDefault = element.default;
      const description = element.description;
      if(isActive){
        const promptMenu = document.querySelector('#features-menu');
        if(isDefault)
          promptMenu.innerHTML+=`&lt;option value="${prompt}" title="${description}" selected&gt;${name}&lt;/option&gt;`;
        else
          promptMenu.innerHTML+=`&lt;option value="${prompt}" title="${description}"&gt;${name}&lt;/option&gt;`;
      }
    })
  }

  function init() {
    if (initDone)
      return;
    initDone = true;
    // Select the form element
    const form = document.querySelector('#userChat');
    if (!form) {
      console.error("xwiki llm js failed to initialize because it could not find the #userChat form");
      return;
    }
    initFormEvent(form);

    const csrf = '${services.csrf.token}';
    const options = getRequestOptions(null, csrf);
    getModels(options);
    getPrompts(options);
  }

  return { init, includeInDoc, handleButtonClick };
});</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse/>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>AI.Code.Javascript</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>cdd170ff-556b-413f-8bf8-bcc567365243</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator>, </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>action=Action|doc.reference=Document|doc.revision|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.cookies|request.headers|request.parameters=Request parameters|request.remoteAddr|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <restricted>0</restricted>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <restricted>0</restricted>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content/>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.requirejs.module</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.requirejs.module.llm</name>
    </property>
    <property>
      <parameters>id=xwiki-llm
path=$xwiki.getURL("AI.Code.Javascript", "jsx", "language=$xcontext.language")</parameters>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
