<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.5" reference="AI.Code.Javascript" locale="">
  <web>AI.Code</web>
  <name>Javascript</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>AI.Code.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <originalMetadataAuthor>XWiki.MunozMateo</originalMetadataAuthor>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity}}
#set($MyDoc = $xwiki.getDocument("AI.Code.AIConfig"))
#set($class = $xwiki.getClass("AI.Code.AIConfigClass"))
#set($objArray = [])

#foreach($obj in $MyDoc.getObjects("AI.Code.AIConfigClass"))
  #set($objData = [])  ## Créez un nouveau tableau pour chaque objet
  #set($discard = $MyDoc.use($obj))
  #foreach($prop in $class.properties) ## Parcourez toutes les propriétés
    ## Ajoutez chaque propriété au tableau de l'objet
    #set($value = $MyDoc.display($prop.getName()))
    #set($discard = $objData.add({ "property": $prop.name, "value": $value }))
  #end

  ## Ajoutez le tableau de l'objet au tableau principal
  #set($discard = $objArray.add($objData))
#end
{{/velocity}}</content>
  <object>
    <name>AI.Code.Javascript</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>62bb6859-7384-4746-a4b3-7c2cb018653e</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <restricted>0</restricted>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>define("xwiki-llm", ['jquery', 'xwiki-events-bridge'], function ($) {
    var initDone = false;
    var nbAssistMsg = 0;
    var context = new Array();
    let contextSize = 0;
    let nbToken = 0;
    let btnEnabled = true;
    let maxToken = 2000;
    let domain = window.location.origin;
    let paramView, paramExist = false;
    let isCustomTemp = false;
    let settingsTemp = 1;

    define('llm-translation', {
        prefix: 'llm.',
        keys: [
            "ui.copy",
            "ui.include",
            "ui.copyLabel",
            "ui.includeLabel",
            "ui.assistantInfoName",
            "ui.editButton",
            "ui.editLabel",
            "ui.settingsTitle",
            "editor.modal.title",
            "ui.tempSlide",
            "ui.isTempUsableLabel",
        ]
    });
    let copyBtnValue;
    let copyBtnLabel
    let includeBtnValue;
    let includeBtnLabel;
    let assistInfoName;
    let editButtonValue;
    let editButtonLabel;
    let settingsTitle;
    let sliderLabel;
    let isTempUsableLabel;
    require(['xwiki-l10n!llm-translation'], function (l10n) {
        copyBtnValue = l10n.get('ui.copy');
        includeBtnValue = l10n.get('ui.include');
        copyBtnLabel = l10n.get('ui.copyLabel');
        includeBtnLabel = l10n.get('ui.includeLabel');
        assistInfoName = l10n.get('ui.assistantInfoName');
        editButtonValue = l10n.get('ui.editButton');
        editButtonLabel = l10n.get('ui.editLabel');
        settingsTitle = l10n.get('ui.settingsTitle');
        sliderLabel = l10n.get('ui.tempSlide');
        isTempUsableLabel = l10n.get('ui.isTempUsableLabel');
    });


    // controler to stop a request if needed.
    let globalAbortController = new AbortController();
    let globalSignal = globalAbortController.signal;

    var loadCSS = function (url) {
        $('&lt;link&gt;').attr({
            type: 'text/css',
            rel: 'stylesheet',
            href: url
        }).appendTo('head');
    };

    var css = [
        // Styles for the editor UI (tool bar, dialogs, etc.).
        new XWiki.Document(XWiki.Model.resolve("AI.Code.StyleSheet", XWiki.EntityType.DOCUMENT)).getURL('ssx'),
    ];
    css.forEach(loadCSS);


    function getRoot() {
        return XWiki.contextPath;
    }


    // Scroll to the bottom of the chat content
    function scrollToBottom() {
        const chatContent = document.querySelector('#chatContent');
        chatContent.scrollTop = chatContent.scrollHeight;
    }

    function autoResizeInput(obj) {
        let scrollHeight = obj.scrollHeight;
        let nbChar = obj.value.length;
        if (scrollHeight &lt; 100) { // min height of 100px
            obj.style.height = '100px';
        } else if (scrollHeight &gt; 200) { // max height 200px
            obj.style.height = '200px';
            obj.style.overflowY = 'auto';
        } else {
            let nbPx = (nbChar / 66) * 18;
            if (nbPx &lt; 100)
                nbPx = 100;
            else if (nbPx &gt; 200)
                nbPx = 200;
            obj.style.height = nbPx + 'px';
        }

    }

    function handleAutoResizeInput() {
        let textarea = document.querySelector('#txt-input');
        textarea.addEventListener('input', (event) =&gt; {
            autoResizeInput(textarea);
        });
        autoResizeInput(textarea);
    }

    function isJSON(str) {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        return true;
    }

    function addUserChat(userChat) {
        const preElement = document.createElement('pre');
        preElement.classList.add('user-message');

        const msgInfo = document.createElement('div');
        msgInfo.classList.add('msg-info');
        msgInfo.textContent = 'User';
        preElement.appendChild(msgInfo);

        const userMessage = document.createElement('div');
        userMessage.id = `user-content-${nbAssistMsg}`;
        userMessage.textContent = userChat;
        preElement.appendChild(userMessage);

        const userMsgButtons = document.createElement('div');
        userMsgButtons.classList.add('msgButtonWrapper');

        const msgBtn = document.createElement('button');
        msgBtn.classList.add('userMsgButton');
        msgBtn.type = 'button';
        msgBtn.id = `user-btn-${nbAssistMsg}`;
        msgBtn.title = editButtonLabel;
        msgBtn.textContent = editButtonValue;
        userMsgButtons.appendChild(msgBtn);
        preElement.appendChild(userMsgButtons);

        return preElement;
    }


    function addAssistantChat(assistantChat, model, elapsedTime) {
        nbAssistMsg++;
        const div = document.createElement('div');
        div.id = `assist-msg-${nbAssistMsg}`;
        div.classList.add('assistant-message');

        const modelInfo = document.createElement('div');
        modelInfo.classList.add('msg-info');
        modelInfo.id = `mod-inf-${nbAssistMsg}`;
        if (isCustomTemp &amp;&amp; paramView) {
            modelInfo.textContent = `${assistInfoName} (${model}) - ${elapsedTime} sec - T: ${settingsTemp}`;
        }
        else {
            modelInfo.textContent = `${assistInfoName} (${model}) - ${elapsedTime} sec`;
        }
        div.appendChild(modelInfo);

        const messageContent = document.createElement('pre');
        messageContent.classList.add('message-content');
        messageContent.id = `msg-content-${nbAssistMsg}`;
        messageContent.textContent = assistantChat;
        div.appendChild(messageContent);

        const astMsgButton = document.createElement('div');
        astMsgButton.classList.add('astMsgButtonWrapper');

        const copyButton = document.createElement('button');
        copyButton.type = 'button';
        copyButton.classList.add('copy-button');
        copyButton.id = `copy-button-${nbAssistMsg}`;
        copyButton.style.display = 'none';
        copyButton.title = copyBtnLabel;
        copyButton.textContent = copyBtnValue;
        astMsgButton.appendChild(copyButton);

        const includeButton = document.createElement('button');
        includeButton.type = 'button';
        includeButton.classList.add('include-button');
        includeButton.id = `include-button-${nbAssistMsg}`;
        includeButton.style.display = 'none';
        includeButton.title = includeBtnLabel;
        includeButton.textContent = includeBtnValue;
        astMsgButton.appendChild(includeButton);

        div.appendChild(astMsgButton);

        return div;
    }


    function addSystemChat(msg, link, linkText) {
        const divElement = document.createElement('div');
        divElement.id = 'system-msg';
        divElement.classList.add('system-message');

        const systemInfo = document.createElement('div');
        systemInfo.classList.add('msg-info');
        systemInfo.textContent = 'System';
        divElement.appendChild(systemInfo);

        const messageContent = document.createElement('pre');
        messageContent.classList.add('message-content');
        messageContent.textContent = msg;
        divElement.appendChild(messageContent);

        const htmlLink = document.createElement('a');
        htmlLink.href = link;
        htmlLink.textContent = linkText;
        divElement.appendChild(htmlLink);

        return divElement;
    }


    // Add the loading animation to the interface.
    function addLoading(chatContent) {
        chatContent.innerHTML += `&lt;div class="waiting-line"&gt;
  &lt;div class="dot dot1"&gt;&lt;/div&gt;
  &lt;div class="dot dot2"&gt;&lt;/div&gt;
  &lt;div class="dot dot3"&gt;&lt;/div&gt;
  &lt;/div&gt;
  `;
        scrollToBottom();
    }

    // Remove the loading animation from the interface.
    function removeLoading(chatContent) {
        const loadingLine = chatContent.querySelector('.waiting-line');
        if (loadingLine) {
            loadingLine.remove();
        }
    }


    function updateAssistantChat(msgIdNum, updatedTime, chunkReply, model) {
        if (isCustomTemp &amp;&amp; paramView)
            document.querySelector('#mod-inf-' + msgIdNum).textContent = `${assistInfoName} (${model}) - ${updatedTime} sec - T: ${settingsTemp}`;
        else
            document.querySelector('#mod-inf-' + msgIdNum).textContent = `${assistInfoName} (${model}) - ${updatedTime} sec`;
        document.querySelector('#msg-content-' + msgIdNum).textContent += chunkReply;
    }

    function errorMessagePrint(errorMessage) {
        return `&lt;div class="errorHandler"&gt;${errorMessage}&lt;/div&gt;`;
    }

    function copyTextToClipboard(numMsgToCopy) {
        return new Promise((resolve, reject) =&gt; {
            const numericID = numMsgToCopy.replace("copy-button-", "");
            const numMsg = parseInt(numericID);
            const text = document.querySelector('#msg-content-' + numMsg).textContent;
            window.getSelection().selectAllChildren(document.querySelector('#msg-content-' + numMsg));
            document.execCommand("Copy");
            window.getSelection().removeAllRanges();
            resolve(text);
        });
    }

    function includeInDoc(msgID) {
        return new Promise((resolve, reject) =&gt; {
            const numericID = msgID.replace("include-button-", "");
            const numMsg = parseInt(numericID);
            const text = document.querySelector('#msg-content-' + numMsg).textContent;
            resolve(text);
        });
    }

    function editUserMsg(msgID) {
        return new Promise((resolve, reject) =&gt; {
            const numericID = msgID.replace("user-btn-", "");
            const numMsg = parseInt(numericID);
            const text = document.querySelector('#user-content-' + numMsg).textContent;
            document.querySelector('#txt-input').value = text;
            autoResizeInput(document.querySelector('#txt-input'));
            resolve(text);
        })
    }

    function chooseMaxToken(modelType) {
        if (modelType !== 'openai') {
            return 2000;
        }
        else return 4000;
    }

    function countTokens(query) {
        let strContext;
        strContext += query.user;
        strContext += query.assistant;
        strContext.trim();
        const words = strContext.split(' ');
        const filteredWords = words.filter(word =&gt; word !== '');
        // One token equal to approximatively 1.3 token (based on OpenAI tokenization)
        const tokenCount = filteredWords.length * 1.3;
        return Math.floor(tokenCount);
    }

    function getRequestParams(userText, modelType, model, prompt, context, temp) {
        const params = {
            text: userText,
            modelType: modelType,
            model: model,
            context: context,
            prompt: prompt,
            temperature: Number(temp),
        };
        return params;
    }

    function getRequestOptions(params, csrf) {
        const options = {
            method: 'POST',
            body: JSON.stringify(params),
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrf
            },
            signal: globalSignal
        };
        return options;
    }

    function tokenManager() {
        nbToken += countTokens(context[contextSize]);
        contextSize++;
        // Manage the number of token so the request is not too long.
        let ind = 0;
        while (nbToken &gt; maxToken) {
            nbToken -= countTokens(context[ind]);
            context.shift();
            ind++;
        }
    }

    function handleButtonClick(event) {
        return new Promise(function (resolve) {
            const target = event.target;
            const msgID = target.id;
            if (target.classList.contains('copy-button')) {
                copyTextToClipboard(msgID);
            }
            else if (target.classList.contains('userMsgButton')) {
                editUserMsg(msgID);
            }
            resolve(msgID);
        });
    }

    // Update the interface and the context with the new infos (non-streaming request only here).
    function updateChat(chatContent, generatedContent, model, elapsedTime, userText) {
        removeLoading(chatContent);
        chatContent.appendChild(addAssistantChat(generatedContent, model, elapsedTime));
        let actualMsgID = nbAssistMsg;
        document.querySelector('#copy-button-' + actualMsgID).style.display = "block";
        document.querySelector('#include-button-' + actualMsgID).style.display = "block";
        context[contextSize].push({user: userText, assistant: generatedContent});
        tokenManager();
    }

    function initChatOnStream(chatContent, model) {
        removeLoading(chatContent);
        chatContent.appendChild(addAssistantChat('', model, 0));
        scrollToBottom();
    }

    function updateChatOnStream(chatContent, completedReply) {
        context[contextSize].assistant = completedReply;
        tokenManager();
        scrollToBottom();
    }

    function errorCatcher(chatContent, error) {
        chatContent.innerHTML += errorMessagePrint("An error occured: " + error.message);
    }

    function changeBtnState() {
        if (btnEnabled) {
            document.querySelector('#subButton').disabled = true;
            document.querySelector('#dropMenu').disabled = true;
            document.querySelector('#stopRqst').style.display = "block";
            btnEnabled = false;
        }
        else {
            document.querySelector('#subButton').disabled = false;
            document.querySelector('#dropMenu').disabled = false;
            document.querySelector('#stopRqst').style.display = "none";
            btnEnabled = true;
        }
    }

    function handleValidChunk(jsonMessages, completedReply, beginRep, isErr, model, startTime, userText) {
        for (const jsonMessage of jsonMessages) {
            if (jsonMessage.trim() !== '') {
                const message = JSON.parse(jsonMessage);
                let reply = '';
                // Extract the generated reply from the response
                if (message.choices[0].finish_reason !== 'stop') {
                    reply = message.choices[0].delta.content;
                }

                // Handle the generated reply as desired
                if (reply) {
                    completedReply += reply;
                    if (completedReply.indexOf("An error occured") !== -1) {
                        isErr = true;
                        chatContent.innerHTML += errorMessagePrint(reply);
                    }
                    else if (completedReply.indexOf('ERROR: ') !== -1) {
                        isErr = true;
                        chatContent.innerHTML += errorMessagePrint("An error occured: " + completedReply);
                    }
                    else {
                        if (beginRep) {
                            initChatOnStream(chatContent, model);
                            beginRep = false;
                        }
                        const elapsedTime = (Date.now() - startTime) / 1000;
                        updateAssistantChat(nbAssistMsg, elapsedTime, reply, model);
                    }
                }

            }
        }
        return { isErr, beginRep, completedReply };
    }

    function processStream({ done, value }, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText) {
        try {
            if (done) {
                if (!isErr) {
                    const copyBtn = document.querySelector('#copy-button-' + nbAssistMsg);
                    const includeBtn = document.querySelector('#include-button-' + nbAssistMsg);
                    if (copyBtn &amp;&amp; includeBtn) {
                        context.push({user: userText}); 
                        copyBtn.style.display = "block";
                        includeBtn.style.display = "block";
                        updateChatOnStream(chatContent, completedReply);
                    }
                    else {
                        throw new Error('The model finished without responding. Please make sure the model can be loaded correctly on the server side. The server may have run out of capacity while running the model.');
                    }
                }
                else {
                    if (isJSON(accumulatedChunks)) {
                        let message = JSON.parse(accumulatedChunks);
                        errorCatcher(chatContent, message.error);
                        removeLoading(chatContent);
                    }
                }
                changeBtnState();
                return;
            }
            else {
                accumulatedChunks += value;

                // Extract complete JSON messages
                let jsonMessages;
                let isValidChunk = true;
                if (accumulatedChunks.indexOf('data: ') !== -1) {
                    jsonMessages = accumulatedChunks.split('data: ').filter(Boolean);
                }
                else {
                    isValidChunk = false;
                }
                // Process complete JSON messages
                if (isValidChunk) {
                    accumulatedChunks = jsonMessages.pop(); // Keep the incomplete message for the next iteration
                    ({ isErr, beginRep, completedReply } = handleValidChunk(jsonMessages, completedReply, beginRep, isErr, model, startTime, userText));
                    return reader.read().then(value =&gt;
                        processStream(value, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText));
                }
                else
                    return reader.read().then(value =&gt;
                        processStream(value, chatContent, completedReply, accumulatedChunks, true, beginRep, reader, model, startTime, userText));
            }
        } catch (error) {
            console.error('error stream : ', error);
            errorCatcher(chatContent, error);
            removeLoading(chatContent);
            changeBtnState();
        }

    }

    function streamResponse(chatContent, stream, model, startTime, userText) {
        const reader = stream.getReader();
        let accumulatedChunks = '';
        let completedReply = '';
        let isErr = false;
        let beginRep = true;

        return reader.read().then(value =&gt;
            processStream(value, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText));
    }

    function streamingRequest(chatContent, URI, options, startTime, model, userText) {
        addLoading(chatContent);
        fetch(URI, options).then((response) =&gt; {
            const reader = response.body.getReader();
            return new ReadableStream({
                start(controller) {
                    function push() {
                        reader.read().then(({ done, value }) =&gt; {
                            if (done) {
                                controller.close();
                                return;
                            }
                            const chunk = new TextDecoder().decode(value);
                            controller.enqueue(chunk);
                            push();
                        });
                    }
                    push();
                }
            });
        }).then((stream) =&gt; {
            return streamResponse(chatContent, stream, model, startTime, userText);
        }).catch((error) =&gt; {
            if (error.name !== 'AbortError') {
                console.error('Error:', error);
                errorCatcher(chatContent, error);
                changeBtnState();
            }
        });
    }

    function requestModeResponse(URI, options, start, model, chatContent, userText) {
        addLoading(chatContent);
        fetch(URI, options)
            .then(response =&gt; response.json())
            .then(data =&gt; {
                const elapsedTime = (Date.now() - start) / 1000;
                if (data.code) {
                    console.error(data.code);
                    chatContent.innerHTML += errorMessagePrint("An error occured: " + data.code + " " + data.description);
                } else if (data.error) {
                    console.error(data.error);
                    chatContent.innerHTML += errorMessagePrint("An error occured: " + data.error.message);
                } else {
                    const content = data.choices[0].message.content;
                    if (content.indexOf('ERROR: ') != -1) {
                        chatContent.innerHTML += errorMessagePrint("An error occured: " + content);
                    }
                    else {
                        updateChat(chatContent, content, model, elapsedTime, userText);
                    }
                }
                scrollToBottom();
                changeBtnState();
            })
            .catch(error =&gt; {
                // Handle any errors except abort error, because
                // this happen on purpose.
                if (error.name !== 'AbortError') {
                    changeBtnState();
                    console.error(error);
                    errorCatcher(chatContent, error);
                }
            });
    }

    function postRequest(options, chatContent, model, userText, isStreaming) {
        changeBtnState();
        document.querySelector('#txt-input').value = '';
        const root = getRoot();
        const URI = root !== '' ? root + "/rest/v1/chat/completions" : "/rest/v1/chat/completions";
        const start = Date.now();
        if (isStreaming === "true") {
            streamingRequest(chatContent, URI, options, start, model, userText);
        }
        else requestModeResponse(URI, options, start, model, chatContent, userText);

    }

    function addTempSettings() {
        const tempSlider = document.createElement('input');
        tempSlider.type = 'range';
        tempSlider.value = settingsTemp;
        tempSlider.min = '0';
        tempSlider.max = '2';
        tempSlider.step = '0.1';
        tempSlider.id = 'sliderTemp';
        tempSlider.style.width = '50%';

        const sliderValueDisplay = document.createElement('input');
        sliderValueDisplay.id = 'sliderValueDisplay';
        sliderValueDisplay.type = 'number';
        sliderValueDisplay.max = '2';
        sliderValueDisplay.min = '0';
        sliderValueDisplay.step = '0.1';
        sliderValueDisplay.value = settingsTemp;
        sliderValueDisplay.style.width = '13%';

        sliderValueDisplay.oninput = function () {
            tempSlider.value = this.value;
            settingsTemp = this.value;
        }

        tempSlider.oninput = function () {
            sliderValueDisplay.value = this.value;
            settingsTemp = this.value;
        }

        const tempLabel = document.createElement('label');
        tempLabel.htmlFor = 'sliderTemp';
        tempLabel.innerHTML = sliderLabel;


        const slideContainer = document.createElement('div');
        slideContainer.style.display = 'flex';
        slideContainer.style.flex = '1';
        slideContainer.style.flexDirection = 'column';
        slideContainer.appendChild(tempLabel);

        const sliderAndValueContainer = document.createElement('div');
        sliderAndValueContainer.style.display = 'flex';
        sliderAndValueContainer.appendChild(tempSlider);
        sliderAndValueContainer.appendChild(sliderValueDisplay);

        const isTempUsable = document.createElement('input');
        isTempUsable.type = 'checkbox';
        isTempUsable.id = 'isTempUsable';
        isTempUsable.style.bottom = '8px';
        const labelTempEditable = document.createElement('label');
        labelTempEditable.htmlFor = 'isTempUsable';
        labelTempEditable.innerHTML = isTempUsableLabel;

        const isTempUsableContainer = document.createElement('div');
        isTempUsableContainer.appendChild(labelTempEditable);
        isTempUsableContainer.appendChild(isTempUsable);
        isTempUsableContainer.style.flex = '1';
        isTempUsableContainer.style.display = 'flex';
        isTempUsableContainer.style.alignItems = 'flex-end';
        isTempUsableContainer.style.justifyContent = 'left';
        isTempUsableContainer.style.marginLeft = '10px';

        sliderAndValueContainer.appendChild(isTempUsableContainer);
        slideContainer.appendChild(sliderAndValueContainer);

        return slideContainer;
    }

    function showParam() {
        if (!paramView &amp;&amp; !paramExist) {
            const settingsDiv = document.createElement('div');
            settingsDiv.id = 'settings';

            const line = document.createElement('hr');
            line.style.marginTop = '10px';
            line.style.marginLeft = '-15px';
            line.style.marginRight = '-15px';
            settingsDiv.appendChild(line);

            const title = document.createElement('h2');
            title.textContent = settingsTitle;
            settingsDiv.appendChild(title);

            settingsDiv.appendChild(addTempSettings());

            document.querySelector('#chatUI').appendChild(settingsDiv);
            paramExist = true;
        }
        else if (!paramView) {
            const settings = document.querySelector('#settings');
            settings.style.display = 'block';
        }
        else {
            const settings = document.querySelector('#settings');
            settings.style.display = 'none';
        }
        paramView = !paramView;

    }

    function getPrompts(options) {
        return new Promise((resolve, reject) =&gt; {
            const chatContent = document.querySelector('#chatContent');
            changeBtnState();
            document.querySelector('#stopRqst').style.display = "none";
            chatContent.appendChild(addSystemChat('Prompts are loading..'), null, null);
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/prompts" : "/rest/v1/prompts";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    initPromptMenu(json);
                    changeBtnState();
                    document.querySelector('#stopRqst').style.display = "none";
                    if (json.length === 0) {
                        const msg = 'There is no prompt to load. You can still use the interface as is, but if you want to add quick actions please add corresponding prompt to the database linked below.';
                        const dbLink = getRoot() !== '' ? domain + getRoot() + '/bin/view/AI/PromptDB/' : '/bin/view/AI/PromptDB/';
                        chatContent.appendChild(addSystemChat(msg, dbLink, 'Application PromptDB'));
                        resolve(false);
                    }
                    else {
                        chatContent.appendChild(addSystemChat('Prompts are loaded.'), null, null);
                        resolve(true);
                    }
                })
                .catch(e =&gt; {
                    console.error('An error occured trying to get the prompt list : ' + e.message);
                    const dbLink = getRoot() !== '' ? domain + getRoot() + '/bin/view/AI/PromptDB/' : '/bin/view/AI/PromptDB/';
                    chatContent.appendChild(addSystemChat('An error occured trying to get the prompt list : ' + e.message +
                        '.' + 'Please look at the prompt database on the link below.', dbLink, 'Application PromptDB'));
                    reject(false);
                })
        });
    }

    function getCheck(csrf_token) {
        return new Promise((resolve, reject) =&gt; {
            const options = getRequestOptions(null, csrf_token);
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/check-access" : "/rest/v1/check-access";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    resolve(json.check);
                })
                .catch(e =&gt; {
                    console.error("An error occured trying to check the rights for the LLM extension.", e)
                })

        });
    }

    function getModels(options) {
        return new Promise((resolve, reject) =&gt; {
            const chatContent = document.querySelector('#chatContent');
            changeBtnState();
            document.querySelector('#stopRqst').style.display = "none";
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/models" : "/rest/v1/models";
            chatContent.appendChild(addSystemChat('Models are loading..', null, null));
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    if (Object.keys(json).length === 0) {
                        throw new Error('There is no models to load');
                    }
                    else {
                        initModelMenu(json);
                        chatContent.appendChild(addSystemChat('Models are now loaded.', null, null));
                        changeBtnState();
                    }
                    resolve(true);
                })
                .catch(e =&gt; {
                    console.error('An error occured trying to get the model list : ' + e.message);
                    const baseURL = '/bin/admin/XWiki/XWikiPreferences?editor=globaladmin&amp;section=AI%20LLM%20Application';
                    const url = getRoot() !== '' ? getRoot() + baseURL : baseURL;
                    const configPage = domain + url;
                    chatContent.appendChild(addSystemChat('An error occured trying to get the model list : ' + e.message +
                        '. Please make sure to have at least one configuration working. Click on the link below to access configuration panel (administrator only).',
                        configPage, 'Configuration panel'));
                    reject(false);
                });
        });
    }

    function isUserAdmin(options) {
        return new Promise((resolve, reject) =&gt; {
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/permission" : "/rest/v1/permission";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    resolve(json.isAdmin);
                })
                .catch(e =&gt; {
                    console.error("An error occured trying to check the user permission for the LLM extension.", e)
                    reject();
                })
        });
    }

    function submitChat(event, form) {
        event.preventDefault(); // Prevent the form from submitting normally
        // Get the text from the textarea
        const userText = form.elements.input.value;
        if (userText === "") {
            alert("Your request is empty, please write an input.");
            return false;
        }

        // Which model should we adress and what feature is wanted
        const modelMenu = document.querySelector('#model-menu');
        const selectedMod = modelMenu.value;
        const modelType = selectedMod.substring(0, selectedMod.indexOf("/"));
        const model = selectedMod.substring(selectedMod.indexOf("/") + 1);
        const selectedPrompt = document.querySelector('#features-menu');
        const prompt = selectedPrompt.value;
        let temp;
        if (paramView) {
            const isTempUsable = document.querySelector('#isTempUsable');
            isCustomTemp = isTempUsable.checked;
            if (isCustomTemp)
                temp = parseFloat(document.querySelector('#sliderTemp').value);
        }
        else
            temp = parseFloat(selectedPrompt.options[selectedPrompt.selectedIndex].getAttribute("data-temp"));
        const isStreaming = modelMenu.options[modelMenu.selectedIndex].getAttribute("data-streaming");;
        maxToken = chooseMaxToken(modelType);
        // Adding the user chat in the page
        const chatContent = document.querySelector('#chatContent');
        if (prompt !== '') {
            if (isCustomTemp)
                chatContent.appendChild(addSystemChat('The prompt used is: ' + prompt + ' With a custom temperature of ' + settingsTemp + '.'));
            else
                chatContent.appendChild(addSystemChat('The prompt used is: ' + prompt));
        }
        chatContent.appendChild(addUserChat(userText));
        scrollToBottom();

        // Create the string containing csrf token
        const csrf = document.querySelector('#form_token').value;
        const params = getRequestParams(userText, modelType, model, prompt, context, temp);
        const options = getRequestOptions(params, csrf);

        // Make the POST request with query parameters
        postRequest(options, chatContent, model, userText, isStreaming);
        document.querySelector('#txt-input').style.height = '100px';
    }

    function abortRequest() {
        globalAbortController.abort();
        const chatContent = document.querySelector('#chatContent');
        chatContent.appendChild(addSystemChat("You aborted the ongoing request."));
        removeLoading(chatContent);
        scrollToBottom();
        changeBtnState();
        // reset the signal
        globalAbortController = new AbortController();
        globalSignal = globalAbortController.signal;
    }

    function initFormEvent(form) {
        // Add an event listener to the form submit event
        const subBtn = document.querySelector('#subButton');
        subBtn.addEventListener('click', (event) =&gt; {
            submitChat(event, form)
        });

        const newConvButton = document.querySelector('#newconv');
        newConvButton.addEventListener('click', (event) =&gt; {
            document.querySelector('#chatContent').innerHTML = '';
            nbAssistMsg = 0;
            context.splice(0, context.length);
            contextSize = 0;
            nbToken = 0;
        });

        const stopRqstButton = document.querySelector('#stopRqst');
        stopRqstButton.addEventListener('click', (event) =&gt; {
            abortRequest();
        });
    }

    async function changeDropMenuOnRight(isAdmin) {
        const menuTiles = document.querySelectorAll('.dropTile');
        menuTiles.forEach(element =&gt; {
            element.style.color = 'grey';
            element.style.pointerEvents = 'none';
        });
        if (isAdmin) {
            menuTiles.forEach(element =&gt; {
                element.style.color = 'black';
                element.style.pointerEvents = 'auto';
            });
        }
        else {
            menuTiles.forEach(element =&gt; {
                if (element.getAttribute('data-protected') === 'false') {
                    element.style.color = 'black';
                    element.style.pointerEvents = 'auto';
                }
                else {
                    element.setAttribute('href', '');
                }
            })
        }
    }

    function initDropMenu(isAdmin) {
        const dropMenuBtn = document.querySelector('#dropMenu');
        dropMenuBtn.addEventListener('click', (event) =&gt; {
            const menuContent = document.querySelector('#dropMenuContent');
            if (menuContent.style.display === 'none' || menuContent.style.display === '') {
                const top = dropMenuBtn.offsetTop + dropMenuBtn.offsetHeight;
                const left = dropMenuBtn.offsetLeft;
                menuContent.style.top = top + "px";
                menuContent.style.left = left + "px";
                menuContent.style.display = 'flex';
            }
            else
                menuContent.style.display = 'none';
        });
        changeDropMenuOnRight(isAdmin);
        document.addEventListener('click', (event) =&gt; {
            const menuContent = document.querySelector('#dropMenuContent');
            const dropMenuBtn = document.querySelector('#dropMenu');
            if (menuContent.style.display === 'flex' &amp;&amp; event.target !== dropMenuBtn)
                menuContent.style.display = 'none';
        });

        const settingsTile = document.querySelector('#settingsTile');
        settingsTile.addEventListener('click', (event) =&gt; {
            if (isAdmin)
                showParam();
        })
    }

    function initModelMenu(modelList) {
        const modelMenu = document.querySelector('#model-menu');
        modelList.forEach(element =&gt; {
            const prefix = element.prefix;
            const filter = element.filter;
            const filterTab = filter.split(',');
            const isStreaming = element.canStream;
            for (let model of element.data) {
                const value = prefix + '/' + model.id;
                const valueToDisplay = model.id + ' (' + prefix + ')';
                if (filterTab.includes(model.id) || filter === '')
                    modelMenu.innerHTML += `&lt;option value="${value}" data-streaming="${isStreaming}"&gt;${valueToDisplay}&lt;/option&gt;`
            }
        });

    }

    function initPromptMenu(promptList) {
        promptList.forEach(element =&gt; {
            const name = element.name;
            const prompt = element.prompt;
            const isActive = element.active;
            const isDefault = element.default;
            const description = element.description;
            const temperature = element.temperature;
            if (isActive) {
                const promptMenu = document.querySelector('#features-menu');
                if (isDefault)
                    promptMenu.innerHTML += `&lt;option value="${prompt}" title="${description}" data-temp="${temperature}" selected&gt;${name}&lt;/option&gt;`;
                else
                    promptMenu.innerHTML += `&lt;option value="${prompt}" title="${description}" data-temp="${temperature}"&gt;${name}&lt;/option&gt;`;
            }
        })
    }

    function init() {
        if (initDone)
            return;
        initDone = true;
        // Select the form element
        const form = document.querySelector('#userChat');
        if (!form) {
            console.error("xwiki llm js failed to initialize because it could not find the #userChat form");
            return;
        }
        initFormEvent(form);
        const csrf = document.querySelector('#form_token').value;
        const options = getRequestOptions(null, csrf);
        Promise.all([isUserAdmin(options)])
            .then((res) =&gt; {
                initDropMenu(res[0]);
            });
        Promise.all([getModels(options), getPrompts(options)])
            .then((res) =&gt; {
                if (res[0] &amp;&amp; res[1])
                    setTimeout(() =&gt; {
                        document.querySelector('#chatContent').innerHTML = '';
                    }, 2000);
            });
        handleAutoResizeInput();
    }

    return { init, includeInDoc, handleButtonClick, getCheck };
});</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse/>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>AI.Code.Javascript</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>cdd170ff-556b-413f-8bf8-bcc567365243</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator>, </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>action=Action|doc.reference=Document|doc.revision|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.cookies|request.headers|request.parameters=Request parameters|request.remoteAddr|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <restricted>0</restricted>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <restricted>0</restricted>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content/>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.requirejs.module</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.requirejs.module.llm</name>
    </property>
    <property>
      <parameters>id=xwiki-llm
path=$xwiki.getURL("AI.Code.Javascript", "jsx", "language=$xcontext.language")</parameters>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
