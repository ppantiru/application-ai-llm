<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.5" reference="AI.Code.Javascript" locale="">
  <web>AI.Code</web>
  <name>Javascript</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>AI.Code.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content/>
  <object>
    <name>AI.Code.Javascript</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>62bb6859-7384-4746-a4b3-7c2cb018653e</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <restricted>0</restricted>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>define("xwiki-llm", ['jquery', 'xwiki-events-bridge'], function ($) {
    // Set Markdown options
    marked.use({
      breaks: true
    });
    var initDone = false;
    var nbAssistMsg = 0;
    var context = new Array();
    let contextSize = 0;
    let nbToken = 0;
    let btnEnabled = true;
    let maxToken = 2000;
    let domain = window.location.origin;
    let paramView, paramExist = false;
    let settingsTemp = 1;
    let promptData;
    let userRef;

    define('llm-translation', {
        prefix: 'llm.',
        keys: [
            "ui.copy",
            "ui.include",
            "ui.copyLabel",
            "ui.includeLabel",
            "ui.assistantInfoName",
            "ui.editButton",
            "ui.editLabel",
            "ui.settingsTitle",
            "editor.modal.title",
            "ui.tempSlide",
            "ui.sysPromptLabel",
            "ui.userPromptLabel",
            "ui.featureMenuPlaceholder",
            "quickaction.name",
            "quickaction.hint",
        ]
    });
    let copyBtnValue;
    let copyBtnLabel
    let includeBtnValue;
    let includeBtnLabel;
    let assistInfoName;
    let editButtonValue;
    let editButtonLabel;
    let settingsTitle;
    let sliderLabel;
    let sysPrptDisLabel;
    let userPrptDisLabel;
    require(['xwiki-l10n!llm-translation'], function (l10n) {
        copyBtnValue = l10n.get('ui.copy');
        includeBtnValue = l10n.get('ui.include');
        copyBtnLabel = l10n.get('ui.copyLabel');
        includeBtnLabel = l10n.get('ui.includeLabel');
        assistInfoName = l10n.get('ui.assistantInfoName');
        editButtonValue = l10n.get('ui.editButton');
        editButtonLabel = l10n.get('ui.editLabel');
        settingsTitle = l10n.get('ui.settingsTitle');
        sliderLabel = l10n.get('ui.tempSlide');
        sysPrptDisLabel = l10n.get('ui.sysPromptLabel');
        userPrptDisLabel = l10n.get('ui.userPromptLabel');
    });



    // controler to stop a request if needed.
    let globalAbortController = new AbortController();
    let globalSignal = globalAbortController.signal;

    var loadCSS = function (url) {
        $('&lt;link&gt;').attr({
            type: 'text/css',
            rel: 'stylesheet',
            href: url
        }).appendTo('head');
    };

    var css = [
        // Styles for the editor UI (tool bar, dialogs, etc.).
        new XWiki.Document(XWiki.Model.resolve("AI.Code.StyleSheet", XWiki.EntityType.DOCUMENT)).getURL('ssx'),
    ];
    css.forEach(loadCSS);


    /**
     *
     * @return The XWiki contextPath
     *
     */
    function getRoot() {
        return XWiki.contextPath;
    }


    /**
     *
     * Scroll to the bottom of the chat box when called.
     *
     */
    function scrollToBottom() {
        const chatContent = document.querySelector('#chatContent');
        chatContent.scrollTop = chatContent.scrollHeight;
    }

    /**
     *
     * @param {HTMLElement} obj A text area.
     * This is used to resize the user input area.
     *
     */
    function autoResizeInput(obj) {
        let scrollHeight = obj.scrollHeight;
        let nbChar = obj.value.length;
        if (scrollHeight &lt; 100) { // min height of 100px
            obj.style.height = '100px';
        } else if (scrollHeight &gt; 200) { // max height 200px
            obj.style.height = '200px';
            obj.style.overflowY = 'auto';
        } else {
            let nbPx = (nbChar / 66) * 18;
            if (nbPx &lt; 100)
                nbPx = 100;
            else if (nbPx &gt; 200)
                nbPx = 200;
            obj.style.height = nbPx + 'px';
        }

    }

    /**
     *
     * Attach an event listener to the user text input area to enable auto resizing. 
     *
     */
    function handleAutoResizeInput() {
        let textarea = document.querySelector('#txt-input');
        textarea.addEventListener('input', (event) =&gt; {
            autoResizeInput(textarea);
        });
        autoResizeInput(textarea);
    }

    /**
     *
     * @param {string} str A string representation of a json.
     * @return true if the string in parameter is valid JSON, else return false.
     *
     */
    function isJSON(str) {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        return true;
    }

    /**
     *
     * @param {string} userChat The user input.
     * @return {HTMLPreElement} An HTML representation of the user chat.
     *
     */
    function addUserChat(userChat) {
        const preElement = document.createElement('pre');
        preElement.classList.add('user-message');

        const msgInfo = document.createElement('div');
        msgInfo.classList.add('msg-info');
        msgInfo.textContent = 'User';
        preElement.appendChild(msgInfo);

        const userMessage = document.createElement('div');
        userMessage.id = `user-content-${nbAssistMsg}`;
        userMessage.textContent = userChat;
        preElement.appendChild(userMessage);

        const userMsgButtons = document.createElement('div');
        userMsgButtons.classList.add('msgButtonWrapper');

        const msgBtn = document.createElement('button');
        msgBtn.classList.add('userMsgButton');
        msgBtn.type = 'button';
        msgBtn.id = `user-btn-${nbAssistMsg}`;
        msgBtn.title = editButtonLabel;
        msgBtn.textContent = editButtonValue;
        userMsgButtons.appendChild(msgBtn);
        preElement.appendChild(userMsgButtons);

        return preElement;
    }

    /**
     * @param {string} assistantChat The LLM AI answer.
     * @param {string} model The LLM model responding.
     * @param {number} elapsedTime The time elapsed between the user chat and this answer in seconde.
     * @return {HTMLDivElement} An HTML representation of the LLM AI answer.
     *
     */
    function addAssistantChat(assistantChat, model, elapsedTime) {
        nbAssistMsg++;
        const div = document.createElement('div');
        div.id = `assist-msg-${nbAssistMsg}`;
        div.classList.add('assistant-message');

        const modelInfo = document.createElement('div');
        modelInfo.classList.add('msg-info');
        modelInfo.id = `mod-inf-${nbAssistMsg}`;
        if (paramView) {
            modelInfo.textContent = `${assistInfoName} (${model}) - ${elapsedTime} sec - T: ${settingsTemp}`;
        }
        else {
            modelInfo.textContent = `${assistInfoName} (${model}) - ${elapsedTime} sec`;
        }
        div.appendChild(modelInfo);

        const messageContent = document.createElement('pre');
        messageContent.classList.add('message-content');
        messageContent.id = `msg-content-${nbAssistMsg}`;
        messageContent.innerHTML = DOMPurify.sanitize(marked.parse(assistantChat), {FORBID_TAGS: ['style'], FORBID_ATTR: ['src']});
        div.appendChild(messageContent);

        const astMsgButton = document.createElement('div');
        astMsgButton.classList.add('astMsgButtonWrapper');

        const copyButton = document.createElement('button');
        copyButton.type = 'button';
        copyButton.classList.add('copy-button');
        copyButton.id = `copy-button-${nbAssistMsg}`;
        copyButton.style.display = 'none';
        copyButton.title = copyBtnLabel;
        copyButton.textContent = copyBtnValue;
        astMsgButton.appendChild(copyButton);

        const includeButton = document.createElement('button');
        includeButton.type = 'button';
        includeButton.classList.add('include-button');
        includeButton.id = `include-button-${nbAssistMsg}`;
        includeButton.style.display = 'none';
        includeButton.title = includeBtnLabel;
        includeButton.textContent = includeBtnValue;
        astMsgButton.appendChild(includeButton);

        div.appendChild(astMsgButton);

        return div;
    }

    /**
     *
     * @param {string} msg The message to display.
     * @param {string} link The link to redirect to (can be set to null)
     * @param {string} linkText The label to display for the link (can be null).
     * @return {HTMLDivElement} An HTML representation of the system chat.
     *
     */
    function addSystemChat(msg, link, linkText) {
        const divElement = document.createElement('div');
        divElement.id = 'system-msg';
        divElement.classList.add('system-message');

        const systemInfo = document.createElement('div');
        systemInfo.classList.add('msg-info');
        systemInfo.textContent = 'System';
        divElement.appendChild(systemInfo);

        const messageContent = document.createElement('pre');
        messageContent.classList.add('message-content');
        messageContent.textContent = msg;
        divElement.appendChild(messageContent);

        const htmlLink = document.createElement('a');
        htmlLink.href = link;
        htmlLink.textContent = linkText;
        divElement.appendChild(htmlLink);

        return divElement;
    }


    /**
     *
     * @param {HTMLElement} chatContent The current chat window of the interface.
     * @return {HTMLDivElement} An HTML representation of the loading animation.
     *
     */
    function addLoading(chatContent) {
        chatContent.innerHTML += `&lt;div class="waiting-line"&gt;
  &lt;div class="dot dot1"&gt;&lt;/div&gt;
  &lt;div class="dot dot2"&gt;&lt;/div&gt;
  &lt;div class="dot dot3"&gt;&lt;/div&gt;
  &lt;/div&gt;
  `;
        scrollToBottom();
    }

    /**
     *
     * Remove the last Loading animation added from the chat.
     * @param {HTMLElement} chatContent The current chat window of the interface.
     *
     */
    function removeLoading(chatContent) {
        const loadingLine = chatContent.querySelector('.waiting-line');
        if (loadingLine) {
            loadingLine.remove();
        }
    }

    /**
     *
     * For streaming request, update the corresponding assistant chat with the new informations.
     * @param {number} msgIdNum The assistant chat ID to update.
     * @param {number} updatedTime The new time to display since the beginning of the interaction in seconde.
     * @param {string} chunkReply The chunk of the answer to add.
     * @param {string} model The LLM model answering.
     *
     */
    function updateAssistantChat(msgIdNum, updatedTime, chunkReply, model) {
        if (paramView)
            document.querySelector('#mod-inf-' + msgIdNum).textContent = `${assistInfoName} (${model}) - ${updatedTime} sec - T: ${settingsTemp}`;
        else
            document.querySelector('#mod-inf-' + msgIdNum).textContent = `${assistInfoName} (${model}) - ${updatedTime} sec`;
        document.querySelector('#msg-content-' + msgIdNum).innerHTML = DOMPurify.sanitize(marked.parse(chunkReply), {FORBID_TAGS: ['style'], FORBID_ATTR: ['src']});
    }

    /**
     *
     * @param {string} errorMessage The error message to display.
     * @return {HTMLDivElement} A div element containing the error message HTML representation.
     *
     */
    function errorMessagePrint(errorMessage) {
        return `&lt;div class="errorHandler"&gt;${errorMessage}&lt;/div&gt;`;
    }

    /**
     * Copy the specified assistant message to clipboard.
     * @param {string} numMsgToCopy The HTML ID of the message to copy.
     * @return {Promise&lt;string&gt;} A promise containing the copied text.
     *
     */
    function copyTextToClipboard(numMsgToCopy) {
        return new Promise((resolve, reject) =&gt; {
            const numericID = numMsgToCopy.replace("copy-button-", "");
            const numMsg = parseInt(numericID);
            const text = document.querySelector('#msg-content-' + numMsg).textContent;
            window.getSelection().selectAllChildren(document.querySelector('#msg-content-' + numMsg));
            document.execCommand("Copy");
            window.getSelection().removeAllRanges();
            resolve(text);
        });
    }

    /**
     * 
     * @param {string} msgID The assistant message HTML ID to include.
     * @return {Promise&lt;string&gt;} A promise containing the HTML to include in the edited document.
     *
     */
    function includeInDoc(msgID) {
        return new Promise((resolve, reject) =&gt; {
            const numericID = msgID.replace("include-button-", "");
            const numMsg = parseInt(numericID);
            const text = document.getElementById('msg-content-' + numMsg).innerHTML;
            resolve(text);
        });
    }

    /**
     *
     * @param {string} msgID The user chat HTML ID to edit.
     * @return {Promise&lt;string&gt;} A promise containing the user chat text to edit. 
     *
     */
    function editUserMsg(msgID) {
        return new Promise((resolve, reject) =&gt; {
            const numericID = msgID.replace("user-btn-", "");
            const numMsg = parseInt(numericID);
            const text = document.querySelector('#user-content-' + numMsg).textContent;
            document.querySelector('#txt-input').value = text;
            autoResizeInput(document.querySelector('#txt-input'));
            resolve(text);
        })
    }

    /**
     * /!\ This method is extremely approximative and need to be change with appropriate tokenizer.
     * @param {JSON} query A json representation of the last context.
     * @return {number} The number of token from the specified query.
     */
    function countTokens(query) {
        let strContext;
        strContext += query.user;
        strContext += query.assistant;
        strContext.trim();
        const words = strContext.split(' ');
        const filteredWords = words.filter(word =&gt; word !== '');
        // One token equal to approximatively 1.3 token (based on OpenAI tokenization)
        const tokenCount = filteredWords.length * 1.3;
        return Math.floor(tokenCount);
    }

    /**
     * Build the parameters to send for the request.
     * @param {array} messages The array of messages to complete
     * @param {string} model The LLM model to send the request.
     * @param {number} temperature The temperature of the chat.
     * @return {Object} An object representing the parameters.
     */
    function getRequestParams(messages, model, temperature) {
        const modelMenu = document.querySelector('#model-menu');
        return {
            messages: messages,
            model: model,
            temperature: Number(temperature),
            stream: modelMenu.options[modelMenu.selectedIndex].getAttribute("data-streaming") === "true"
        };
    }

    /**
     * Build the options for the fetch request to the API.
     * @param {JSON} params The body of the request, can be set to null.
     * @param {string} csrf The CSRF token. Needed for the validity of the request.
     * @returns {JSON} A JSON representation of the request options. 
     */
    function getRequestOptions(params, csrf) {
        if (params != null) {
            params.currentWiki = XWiki.currentWiki;
            params.userName = userRef;
        }
        else {
            params = { currentWiki: XWiki.currentWiki, userName: userRef };
        }
        const options = {
            method: 'POST',
            body: JSON.stringify(params),
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'X-CSRFToken': csrf
            },
            signal: globalSignal
        };
        return options;
    }

    /**
     * /!\ This method is extremely approximative and need to be change with appropriate tokenizer.
     * Manage the context size based on the number of token and the maximum token usable.
     */
    function tokenManager() {
        nbToken += countTokens(context[contextSize]);
        contextSize++;
        // Manage the number of token so the request is not too long.
        let ind = 0;
        while (nbToken &gt; maxToken) {
            nbToken -= countTokens(context[ind]);
            context.shift();
            ind++;
        }
    }

    /**
     * Handle some of the button click event (copy and edit).
     * @param {Event} event the catched event.
     * @return {Promise&lt;string&gt;} A promise containing The HTML ID of the element the click came from.
     */
    function handleButtonClick(event) {
        return new Promise(function (resolve) {
            const target = event.target;
            const msgID = target.id;
            if (target.classList.contains('copy-button')) {
                copyTextToClipboard(msgID);
            }
            else if (target.classList.contains('userMsgButton')) {
                editUserMsg(msgID);
            }
            resolve(msgID);
        });
    }

    /**
     * Update the interface and the context with the new infos (non-streaming request only here).
     * @param {HTMLElement} chatContent The chat box element.
     * @param {string} generatedContent The full answer from the LLM model.
     * @param {string} model The LLM model name.
     * @param {number} elapsedTime The time elapsed since the user chat has been send in seconde.
     * @param {string} userText The user text sended (used here to fullfill the context).
     */
    function updateChat(chatContent, generatedContent, model, elapsedTime, userText) {
        removeLoading(chatContent);
        chatContent.appendChild(addAssistantChat(generatedContent, model, elapsedTime));
        let actualMsgID = nbAssistMsg;
        document.querySelector('#copy-button-' + actualMsgID).style.display = "block";
        document.querySelector('#include-button-' + actualMsgID).style.display = "block";
        context.push({ user: userText, assistant: generatedContent });
        tokenManager();
    }

    /**
     * Init the new chat that begin to be received.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {string} model The LLM model name.
     */
    function initChatOnStream(chatContent, model) {
        removeLoading(chatContent);
        chatContent.appendChild(addAssistantChat('', model, 0));
        scrollToBottom();
    }

    /**
     * Update the chat information in the back (number of token and context) at the end of the stream communication.
     * @param {string} completedReply The full reply at the end of the communication.
     */
    function updateChatOnStream(completedReply) {
        context[contextSize].assistant = completedReply;
        tokenManager();
        scrollToBottom();
    }

    /**
     * Add an error message to the chat box.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {JSON} error The JSON object containing error information. 
     */
    function errorCatcher(chatContent, error) {
        chatContent.innerHTML += errorMessagePrint("An error occured: " + error.message);
    }

    /**
     * Change the interface button state based on their actual state.
     */
    function changeBtnState() {
        if (btnEnabled) {
            document.querySelector('#subButton').disabled = true;
            document.querySelector('#dropMenu').disabled = true;
            document.querySelector('#stopRqst').style.display = "block";
            btnEnabled = false;
        }
        else {
            document.querySelector('#subButton').disabled = false;
            document.querySelector('#dropMenu').disabled = false;
            document.querySelector('#stopRqst').style.display = "none";
            btnEnabled = true;
        }
    }

    /**
     * Handle a chunk of reply comming from the stream communication with the LLM model.
     * @param {string} jsonMessages The string representation of the chunk of the reply to treat.
     * @param {string} completedReply The string containing the full reply until now.
     * @param {boolean} beginRep State if the answer already started or not. 
     * @param {boolean} isErr State if the chunk received is an error or not. 
     * @param {string} model The LLM model name.
     * @param {number} startTime The Date in ms the assistant started writing.
     * @return {JSON} A JSON object containing the updated state of isErr, beginRep, and completedReply.
     */
    function handleValidChunk(jsonMessages, completedReply, beginRep, isErr, model, startTime) {
        for (const jsonMessage of jsonMessages) {
            if (jsonMessage.trim() !== '') {
                const message = JSON.parse(jsonMessage);
                let reply = '';
                // Extract the generated reply from the response
                if (message.choices.length &gt; 0) {
                    reply = message.choices[0].delta.content;
                }

                // Handle the generated reply as desired
                if (reply) {
                    completedReply += reply;
                    if (beginRep) {
                        initChatOnStream(chatContent, model);
                        beginRep = false;
                    }
                    const elapsedTime = (Date.now() - startTime) / 1000;
                    updateAssistantChat(nbAssistMsg, elapsedTime, completedReply, model);
                }

            }
        }
        return { isErr, beginRep, completedReply };
    }

    /**
     * Process the stream request and update the interface along.
     * @param {Object} obj An object with 'done' and 'value'. 'done' is a boolean true if the request has ended, else false. 'value' is the last string value communicated.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {string} completedReply The string containing the full reply until now.
     * @param {string} accumulatedChunks The string containing every json representation of the received chunk.
     * @param {string} isErr State if the chunk received is an error or not. 
     * @param {string} beginRep State if the answer already started or not. 
     * @param {any} reader The reader used to read the stream.
     * @param {string} model The LLM model name.
     * @param {number} startTime The Date in ms the assistant started writing.
     * @param {string} userText The user text corresponding to this request.
     */
    function processStream({ done, value }, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText) {
        try {
            if (done) {
                if (!isErr) {
                    const copyBtn = document.querySelector('#copy-button-' + nbAssistMsg);
                    const includeBtn = document.querySelector('#include-button-' + nbAssistMsg);
                    if (copyBtn &amp;&amp; includeBtn) {
                        context.push({ user: userText });
                        copyBtn.style.display = "block";
                        includeBtn.style.display = "block";
                        updateChatOnStream(completedReply);
                    }
                    else {
                        throw new Error('The model finished without responding. Please make sure the model can be loaded correctly on the server side. The server may have run out of capacity while running the model.');
                    }
                }
                else {
                    if (isJSON(accumulatedChunks)) {
                        let message = JSON.parse(accumulatedChunks);
                        errorCatcher(chatContent, message.error);
                        removeLoading(chatContent);
                    }
                }
                changeBtnState();
                return;
            }
            else {
                accumulatedChunks += value;

                // Extract complete JSON messages
                let jsonMessages;
                let isValidChunk = true;
                if (accumulatedChunks.indexOf('data: ') !== -1) {
                    jsonMessages = accumulatedChunks.split('data: ').filter(Boolean);
                }
                else {
                    isValidChunk = false;
                }
                // Process complete JSON messages
                if (isValidChunk) {
                    accumulatedChunks = jsonMessages.pop(); // Keep the incomplete message for the next iteration
                    ({ isErr, beginRep, completedReply } = handleValidChunk(jsonMessages, completedReply, beginRep, isErr, model, startTime));
                    return reader.read().then(value =&gt;
                        processStream(value, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText));
                }
                else
                    return reader.read().then(value =&gt;
                        processStream(value, chatContent, completedReply, accumulatedChunks, true, beginRep, reader, model, startTime, userText));
            }
        } catch (error) {
            console.error('error stream : ', error);
            errorCatcher(chatContent, error);
            removeLoading(chatContent);
            changeBtnState();
        }

    }

    /**
     * Set up the start of the process for the streaming response of the LLM model.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {Object} stream The actual stream object.
     * @param {string} model The LLM model name.
     * @param {number} startTime The Date in ms the assistant started writing.
     * @param {string} userText The user text corresponding to this request.
     */
    function streamResponse(chatContent, stream, model, startTime, userText) {
        const reader = stream.getReader();
        let accumulatedChunks = '';
        let completedReply = '';
        let isErr = false;
        let beginRep = true;

        return reader.read().then(value =&gt;
            processStream(value, chatContent, completedReply, accumulatedChunks, isErr, beginRep, reader, model, startTime, userText));
    }

    /**
     * Initialize the stream request.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {string} URI The URI where the request has to be sent. 
     * @param {JSON} options The JSON representation of the request options. 
     * @param {number} startTime The Date in ms the assistant started writing.
     * @param {string} userText The user text corresponding to this request.
     */
    function streamingRequest(chatContent, URI, options, startTime, model, userText) {
        addLoading(chatContent);
        fetch(URI, options).then((response) =&gt; {
            const reader = response.body.getReader();
            return new ReadableStream({
                start(controller) {
                    function push() {
                        reader.read().then(({ done, value }) =&gt; {
                            if (done) {
                                controller.close();
                                return;
                            }
                            const chunk = new TextDecoder().decode(value);
                            controller.enqueue(chunk);
                            push();
                        });
                    }
                    push();
                }
            });
        }).then((stream) =&gt; {
            return streamResponse(chatContent, stream, model, startTime, userText);
        }).catch((error) =&gt; {
            if (error.name !== 'AbortError') {
                console.error('Error:', error);
                errorCatcher(chatContent, error);
                changeBtnState();
            }
        });
    }

    /**
     * Make the request for non-streaming request.
     * @param {string} URI The URI where the request has to be sent. 
     * @param {JSON} options The JSON representation of the request options. 
     * @param {number} startTime The Date in ms the assistant started writing.
     * @param {string} model The LLM model name.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {string} userText The user text corresponding to this request.
     */
    function requestModeResponse(URI, options, startTime, model, chatContent, userText) {
        addLoading(chatContent);
        fetch(URI, options)
            .then(response =&gt; response.json())
            .then(data =&gt; {
                const elapsedTime = (Date.now() - startTime) / 1000;
                if (data.code) {
                    console.error(data.code);
                    chatContent.innerHTML += errorMessagePrint("An error occured: " + data.code + " " + data.description);
                } else if (data.error) {
                    console.error(data.error);
                    chatContent.innerHTML += errorMessagePrint("An error occured: " + data.error.message);
                } else {
                    const content = data.choices[0].message.content;
                    updateChat(chatContent, content, model, elapsedTime, userText);

                }
                scrollToBottom();
                changeBtnState();
            })
            .catch(error =&gt; {
                // Handle any errors except abort error, because
                // this happen on purpose.
                if (error.name !== 'AbortError') {
                    changeBtnState();
                    console.error(error);
                    errorCatcher(chatContent, error);
                }
            });
    }

    /**
     * Method called to make every request to the models.
     * @param {JSON} options The JSON representation of the request options.
     * @param {HTMLElement} chatContent The chat box element.
     * @param {string} model The LLM model name.
     * @param {string} userText The user text corresponding to this request.
     * @param {boolean} isStreaming true if the request can be streamed, else false.
     */
    function postRequest(options, chatContent, model, userText, isStreaming) {
        changeBtnState();
        document.querySelector('#txt-input').value = '';
        const root = getRoot();
        const URI = `${root}/rest/wikis/${XWiki.currentWiki}/aiLLM/v1/chat/completions`;
        const start = Date.now();
        if (isStreaming === "true") {
            streamingRequest(chatContent, URI, options, start, model, userText);
        }
        else requestModeResponse(URI, options, start, model, chatContent, userText);

    }

    /**
     * Build the prompt settings part of the settings in HTML.
     * @return {HTMLDivElement} The div containing the prompt displayer.
     */
    function promptSettings() {
        const sysPromptDisplay = document.createElement('textarea');
        sysPromptDisplay.id = 'sysPromptDisplay';
        sysPromptDisplay.style.resize = 'none';
        sysPromptDisplay.style.height = '100px';
        sysPromptDisplay.textContent = promptData.prompt;
        const sysPromptDisplayLabel = document.createElement('label');
        sysPromptDisplayLabel.htmlFor = 'sysPromptDisplay';
        sysPromptDisplayLabel.innerHTML = sysPrptDisLabel;
        const sysPromptDisplayContainer = document.createElement('div');
        sysPromptDisplayContainer.style.flex = '1';
        sysPromptDisplayContainer.style.display = 'flex';
        sysPromptDisplayContainer.style.flexDirection = 'column';
        sysPromptDisplayContainer.appendChild(sysPromptDisplayLabel);
        sysPromptDisplayContainer.appendChild(sysPromptDisplay);

        sysPromptDisplay.onchange = function () {
            promptData.prompt = this.value;
        }

        const promptDisplayContainer = document.createElement('div');
        promptDisplayContainer.style.display = 'flex';
        promptDisplayContainer.style.flexDirection = 'column';
        promptDisplayContainer.appendChild(sysPromptDisplayContainer);

        return promptDisplayContainer;
    }

    /**
     * Build the temperature settings part of the settings in HTML.
     * @return {HTMLDivElement} The div containing the temperature slider + displayer.
     */
    function tempSettings() {
        const tempSlider = document.createElement('input');
        tempSlider.type = 'range';
        tempSlider.value = promptData.temperature;
        tempSlider.min = '0';
        tempSlider.max = '2';
        tempSlider.step = '0.1';
        tempSlider.id = 'sliderTemp';
        tempSlider.style.width = '50%';

        const sliderValueDisplay = document.createElement('input');
        sliderValueDisplay.id = 'sliderValueDisplay';
        sliderValueDisplay.type = 'number';
        sliderValueDisplay.max = '2';
        sliderValueDisplay.min = '0';
        sliderValueDisplay.step = '0.1';
        sliderValueDisplay.value = promptData.temperature;
        sliderValueDisplay.style.width = '13%';

        sliderValueDisplay.oninput = function () {
            tempSlider.value = this.value;
            settingsTemp = this.value;
        }

        tempSlider.oninput = function () {
            sliderValueDisplay.value = this.value;
            settingsTemp = this.value;
        }

        const tempLabel = document.createElement('label');
        tempLabel.htmlFor = 'sliderTemp';
        tempLabel.innerHTML = sliderLabel;

        const slideContainer = document.createElement('div');
        slideContainer.style.display = 'flex';
        slideContainer.style.flex = '1';
        slideContainer.style.flexDirection = 'column';
        slideContainer.appendChild(tempLabel);

        const sliderAndValueContainer = document.createElement('div');
        sliderAndValueContainer.style.display = 'flex';
        sliderAndValueContainer.appendChild(tempSlider);
        sliderAndValueContainer.appendChild(sliderValueDisplay);

        slideContainer.appendChild(sliderAndValueContainer);

        return slideContainer;
    }

    /**
     * Build the settings part if it doesnt exist. Else, display/hide the parameter based on their state.
     */
    function showParam() {
        if (!paramView &amp;&amp; !paramExist) {
            const settingsDiv = document.createElement('div');
            settingsDiv.id = 'settings';

            const line = document.createElement('hr');
            line.style.marginTop = '10px';
            line.style.marginLeft = '-15px';
            line.style.marginRight = '-15px';
            settingsDiv.appendChild(line);

            const title = document.createElement('h2');
            title.textContent = settingsTitle;
            settingsDiv.appendChild(title);

            settingsDiv.appendChild(tempSettings());
            settingsDiv.appendChild(promptSettings());

            document.querySelector('#chatUI').appendChild(settingsDiv);
            paramExist = true;
        }
        else if (!paramView) {
            const sysPromptDisplay = document.querySelector('#sysPromptDisplay');
            sysPromptDisplay.textContent = promptData.prompt;
            const settings = document.querySelector('#settings');
            settings.style.display = 'block';
        }
        else {
            const settings = document.querySelector('#settings');
            settings.style.display = 'none';
        }
        paramView = !paramView;

    }

    /**
     * @param {JSON} options The JSON representation of the request options.
     * @return {Promise&lt;JSON&gt;} A promise containing a JSON object with the chosen prompt information.
     */
    function getPrompt(options) {
        return new Promise((resolve, reject) =&gt; {
            const chatContent = document.querySelector('#chatContent');
            changeBtnState();
            document.querySelector('#stopRqst').style.display = "none";
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/prompt" : "/rest/v1/prompt";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    changeBtnState();
                    document.querySelector('#stopRqst').style.display = "none";
                    if (json.name === 'default') {
                        if (JSON.parse(options.body).prompt !== '') {
                            const msg = 'There is no such prompt as \"' + JSON.parse(options.body).prompt + '\" to load, no prompt are used. You can still use the interface as is, but if you want to add quick actions please add corresponding prompt to the database linked below.';
                            const dbLink = getRoot() + "/" + XWiki.servletpath + 'view/AI/PromptDB/';
                            chatContent.appendChild(addSystemChat(msg, dbLink, 'Application PromptDB'));
                        }
                        json = { prompt: '', temperature: 1 };
                        resolve(json);
                    }
                    else {
                        resolve(json);
                    }
                })
                .catch(e =&gt; {
                    console.error('An error occured trying to get the prompt : ' + e.message);
                    const dbLink = getRoot() + "/" + XWiki.servletpath + 'view/AI/PromptDB/';
                    chatContent.appendChild(addSystemChat('An error occured trying to get the prompt list : ' + e.message +
                        '.' + 'Please look at the prompt database on the link below.', dbLink, 'Application PromptDB'));
                    reject(null);
                })
        });
    }

    /**
     * @return {Promise&lt;JSON&gt;} A promise containing a JSON object with every prompts stocked in the prompt database of the current wiki.
     */
    function getPrompts() {
        const csrf = document.querySelector('#form_token').value;
        const options = getRequestOptions(null, csrf)
        return new Promise((resolve, reject) =&gt; {
            const chatContent = document.querySelector('#chatContent');
            changeBtnState();
            document.querySelector('#stopRqst').style.display = "none";
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/prompts" : "/rest/v1/prompts";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    changeBtnState();
                    document.querySelector('#stopRqst').style.display = "none";
                    resolve(json);
                })
                .catch(e =&gt; {
                    console.error('An error occured trying to get the prompt : ' + e.message);
                    const dbLink = getRoot() + "/" + XWiki.servletpath + 'view/AI/PromptDB/';
                    chatContent.appendChild(addSystemChat('An error occured trying to get the prompt list : ' + e.message +
                        '.' + 'Please look at the prompt database on the link below.', dbLink, 'Application PromptDB'));
                    reject(null);
                })
        });
    }

    /**
     * @param {string} csrf_token The csrf token needed for the validity of the request.
     * @param {string} currentUserRef The reference of the user using the extensions (like : wiki:XWiki.UserNickname).  
     * @return {Promise&lt;Boolean&gt;} A promise containing a boolean value. True if the user is hable to use the extension, else false.
     */
    function getCheck(csrf_token, currentUserRef) {
        return new Promise((resolve, reject) =&gt; {
            userRef = currentUserRef;
            const options = getRequestOptions(null, csrf_token);
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/check-access" : "/rest/v1/check-access";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    resolve(json.check);
                })
                .catch(e =&gt; {
                    console.error("An error occured trying to check the rights for the LLM extension.", e)
                })
        });
    }

    /**
     * @return {Promise&lt;JSON&gt;} A promise containing a JSON object with the models usable by the current user.
     */
    function getModels() {
        return new Promise((resolve, reject) =&gt; {
            const chatContent = document.querySelector('#chatContent');
            changeBtnState();
            document.querySelector('#stopRqst').style.display = "none";
            const root = getRoot();
            const URI = `${root}/rest/wikis/${XWiki.currentWiki}/aiLLM/v1/models`;
            chatContent.appendChild(addSystemChat('Models are loading..', null, null));
            fetch(URI, {
                headers: {
                    'Accept': 'application/json'
                },
                signal: globalSignal
            })
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    if (json.data.length === 0) {
                        throw new Error('There is no models to load');
                    }
                    else {
                        initModelMenu(json.data);
                        chatContent.appendChild(addSystemChat('Models are now loaded.', null, null));
                    }
                    resolve(true);
                })
                .catch(e =&gt; {
                    console.error('An error occured trying to get the model list : ' + e.message);
                    const configPage = getRoot() + "/" + XWiki.servletpath + "admin/XWiki/XWikiPreferences?editor=globaladmin&amp;section=AI%20LLM%20Application";
                    chatContent.appendChild(addSystemChat('An error occured trying to get the model list : ' + e.message +
                        '. Please make sure to have at least one configuration working. Click on the link below to access configuration panel (administrator only).',
                        configPage, 'Configuration panel'));
                    reject(false);
                });
        });
    }

    /**
     * @param {JSON} options The JSON representation of the request options.
     * @return {Promise&lt;Boolean&gt;} A promise containing a boolean. True if the user is an admin else false.
     */
    function isUserAdmin(options) {
        return new Promise((resolve, reject) =&gt; {
            const root = getRoot();
            const URI = root !== '' ? root + "/rest/v1/permission" : "/rest/v1/permission";
            fetch(URI, options)
                .then(response =&gt; {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(json =&gt; {
                    resolve(json.isAdmin);
                })
                .catch(e =&gt; {
                    console.error("An error occured trying to check the user permission for the LLM extension.", e)
                    reject();
                })
        });
    }

    /**
     * Send the user chat to the models. Bind parameters to make the request.
     * @param {Event} event The sending event.
     * @param {HTMLFormElement} form The form element of the interface.
     */
    function submitChat(event, form) {
        event.preventDefault(); // Prevent the form from submitting normally
        // Get the text from the textarea
        const userText = form.elements.input.value;
        if (userText === "") {
            alert("Your request is empty, please write an input.");
            return false;
        }

        // Create the string containing csrf token
        const csrf = document.querySelector('#form_token').value;
        // Which model should we adress and what feature is wanted
        const modelMenu = document.querySelector('#model-menu');
        const model = modelMenu.value;
        const contextLength = Number(modelMenu.options[modelMenu.selectedIndex].getAttribute("data-context-length"));
        let temp;
        if (paramView) {
            const sliderTempVal = parseFloat(document.querySelector('#sliderTemp').value);
            const promptTempVal = parseFloat(promptData.temperature);
            if (sliderTempVal !== promptTempVal)
                temp = sliderTempVal;
        }
        else
            temp = promptData.temperature;
        const isStreaming = modelMenu.options[modelMenu.selectedIndex].getAttribute("data-streaming");
        maxToken = contextLength &gt; 0 ? maxToken : 2000;
        // Adding the user chat in the page
        const chatContent = document.querySelector('#chatContent');
        if (promptData.prompt !== '') {
            if (paramView)
                chatContent.appendChild(addSystemChat('The prompt used is: ' + promptData.prompt + ' With a custom temperature of ' + settingsTemp + '.'));
            else
                chatContent.appendChild(addSystemChat('The prompt used is: ' + promptData.prompt));
        }
        chatContent.appendChild(addUserChat(userText));
        scrollToBottom();

        // Build the messages to send.
        const messages = [];
        // Add the system prompt in promptData.prompt
        if (promptData.prompt !== '') {
            messages.push({"role": "system", "content": promptData.prompt});
        }
        // Add the context messages.
        for (let i = 0; i &lt; contextSize; i++) {
            messages.push({"role": "user", "content": context[i].user});
            messages.push({"role": "assistant", "content": context[i].assistant});
        }
        // Add the user message.
        messages.push({"role": "user", "content": userText});

        const params = getRequestParams(messages, model, temp);
        const options = {
            method: 'POST',
            body: JSON.stringify(params),
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            signal: globalSignal
        };

        // Make the POST request with query parameters
        postRequest(options, chatContent, model, userText, isStreaming);
        document.querySelector('#txt-input').style.height = '100px';
    }

    /**
     * Method used to abort the ongoing request.
     */
    function abortRequest() {
        globalAbortController.abort();
        const chatContent = document.querySelector('#chatContent');
        chatContent.appendChild(addSystemChat("You aborted the ongoing request."));
        removeLoading(chatContent);
        scrollToBottom();
        changeBtnState();
        // reset the signal
        globalAbortController = new AbortController();
        globalSignal = globalAbortController.signal;
    }

    /**
     * Initialize the prompt menu and set up event listener on it.
     * @param {JSON} promptDB The JSON Array containing every available prompt from the prompt database of the current wiki.
     */
    function initPromptMenu(promptDB) {
        require(['jquery', 'xwiki-selectize'], function ($) {
            const csrf = document.querySelector('#form_token').value;
            const selectedPrompt = $('#features-menu').selectize();
            selectedPrompt[0].selectize.settings.maxOptions = 5;
            // when selectize is loaded.
            selectedPrompt[0].selectize.on('load', function () {
                promptDB.forEach(element =&gt; {
                    if (!element.active) {
                        selectedPrompt[0].selectize.removeOption(element.pageName);
                    }
                    else if (element.default) {
                        selectedPrompt[0].selectize.setValue(element.pageName);
                    }
                });
            });
            selectedPrompt[0].selectize.on('change', function (value) {
                const optionsPromptRqChange = getRequestOptions({ prompt: value }, csrf);
                if (value !== '') {
                    Promise.all([getPrompt(optionsPromptRqChange)])
                        .then((res) =&gt; {
                            promptData = res[0];
                            document.querySelector('#txt-input').value = promptData.userPrompt !== undefined ? promptData.userPrompt : '';
                            if (paramExist) {
                                document.querySelector('#sysPromptDisplay').value = promptData.prompt;
                                document.querySelector('#sliderTemp').value = promptData.temperature;
                                document.querySelector('#sliderValueDisplay').value = promptData.temperature;
                            }
                        });
                }
                else {
                    promptData = { prompt: '', temperature: 1 };
                    document.querySelector('#txt-input').value = '';
                    if (paramExist) {
                        document.querySelector('#sysPromptDisplay').value = '';
                    }
                }
            });
        });
    }

    /**
     * Initialize form event.
     * @param {HTMLFormElement} form The form HTML element of the interface.
     */
    function initFormEvent(form) {
        // Add an event listener to the form submit event
        const subBtn = document.querySelector('#subButton');
        subBtn.addEventListener('click', (event) =&gt; {
            submitChat(event, form)
        });

        // Listen for the Enter key press within the form
        form.addEventListener('keypress', (event) =&gt; {
            if (event.key === 'Enter' &amp;&amp; !event.shiftKey) {
                event.preventDefault(); // Prevent the form from submitting
                submitChat(event, form);
            }
        });

        const newConvButton = document.querySelector('#newconv');
        newConvButton.addEventListener('click', (event) =&gt; {
            document.querySelector('#chatContent').innerHTML = '';
            nbAssistMsg = 0;
            context.splice(0, context.length);
            contextSize = 0;
            nbToken = 0;
        });

        const stopRqstButton = document.querySelector('#stopRqst');
        stopRqstButton.addEventListener('click', (event) =&gt; {
            abortRequest();
        });

        promptData = { prompt: '', temperature: 1 };
    }

    /**
     * Change the access of the button on the drop down menu based on user right.
     * @param {boolean} isAdmin boolean indicating if the user is an admin or not.
     */
    async function changeDropMenuOnRight(isAdmin) {
        const menuTiles = document.querySelectorAll('.dropTile');
        menuTiles.forEach(element =&gt; {
            element.style.color = 'grey';
            element.style.pointerEvents = 'none';
        });
        document.querySelector('#promptDBRedir').href = getRoot() + "/" + XWiki.servletpath + "view/AI/PromptDB/";
        if (isAdmin) {
            menuTiles.forEach(element =&gt; {
                element.style.color = 'black';
                element.style.pointerEvents = 'auto';
            });
            document.querySelector('#configRedir').href = getRoot() + "/" + XWiki.servletpath + "admin/XWiki/XWikiPreferences?editor=globaladmin&amp;section=AI%20LLM%20Application";
        }
        else {
            menuTiles.forEach(element =&gt; {
                if (element.getAttribute('data-protected') === 'false') {
                    element.style.color = 'black';
                    element.style.pointerEvents = 'auto';
                }
                else {
                    element.setAttribute('href', '');
                }
            })
        }

    }

    /**
     * Initialize the drop menu based on the user right.
     * @param {boolean} isAdmin boolean indicating if the user is an admin or not.
     */
    function initDropMenu(isAdmin) {
        const dropMenuBtn = document.querySelector('#dropMenu');
        dropMenuBtn.addEventListener('click', (event) =&gt; {
            const menuContent = document.querySelector('#dropMenuContent');
            if (menuContent.style.display === 'none' || menuContent.style.display === '') {
                const top = dropMenuBtn.offsetTop + dropMenuBtn.offsetHeight;
                const left = dropMenuBtn.offsetLeft - 114;
                menuContent.style.top = top + "px";
                menuContent.style.left = left + "px";
                menuContent.style.display = 'flex';
            }
            else
                menuContent.style.display = 'none';
        });
        changeDropMenuOnRight(isAdmin);
        document.addEventListener('click', (event) =&gt; {
            const menuContent = document.querySelector('#dropMenuContent');
            const dropMenuBtn = document.querySelector('#dropMenu');
            if (menuContent.style.display === 'flex' &amp;&amp; event.target !== dropMenuBtn)
                menuContent.style.display = 'none';
        });

        const settingsTile = document.querySelector('#settingsTile');
        settingsTile.addEventListener('click', (event) =&gt; {
            showParam();
        })
    }

    /**
     * Initialize the LLM model menu.
     * @param {Array} modelList Array containing every LLM models available for the current user.
     */
    function initModelMenu(modelList) {
        const modelMenu = document.querySelector('#model-menu');
        modelList.forEach(element =&gt; {
            const optionElement = document.createElement('option');
            optionElement.value = element.id;
            optionElement.textContent = element.name;
            optionElement.setAttribute('data-streaming', element.can_stream);
            optionElement.setAttribute('data-context-length', element.context_length);
            modelMenu.appendChild(optionElement);
        });

    }

    /**
     * @return {Promise&lt;string&gt;} A promise containing the full user name (like wiki:XWiki.UserNickname).
     */
    function getUserName() {
        return new Promise((resolve, reject) =&gt; {
            require(['xwiki-meta'], function (xm) {
                resolve(XWiki.Model.serialize(xm.userReference));
            });
        })
    }

    /**
     * Initialize the LLM extension.
     */
    async function init() {
        if (initDone)
            return;
        initDone = true;
        // Select the form element
        const form = document.querySelector('#userChat');
        if (!form) {
            console.error("xwiki llm js failed to initialize because it could not find the #userChat form");
            return;
        }
        userRef = await getUserName();
        const csrf = document.querySelector('#form_token').value;
        const options = getRequestOptions(null, csrf);
        Promise.all([initFormEvent(form), isUserAdmin(options), getModels()])
            .then((res) =&gt; {
                initDropMenu(res[1]);
                if (res[2])
                    setTimeout(() =&gt; {
                        document.querySelector('#chatContent').innerHTML = '';
                        changeBtnState();
                    }, 2000);
            });
        handleAutoResizeInput();
    }

    return { init, includeInDoc, handleButtonClick, getCheck, initPromptMenu, getPrompts };
});
</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse/>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>AI.Code.Javascript</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>cdd170ff-556b-413f-8bf8-bcc567365243</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator>, </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>action=Action|doc.reference=Document|doc.revision|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.cookies|request.headers|request.parameters=Request parameters|request.remoteAddr|request.session|request.url=Request URL|request.wiki=Request wiki|sheet|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <restricted>0</restricted>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <restricted>0</restricted>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content/>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.requirejs.module</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.requirejs.module.llm</name>
    </property>
    <property>
      <parameters>id=xwiki-llm
path=$xwiki.getURL("AI.Code.Javascript", "jsx", "language=$xcontext.language")</parameters>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
